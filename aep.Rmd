---
title: "Advanced Econometrics Project"
author: "Mattia Elezi"
date: "05/05/2022"
output:
  pdf_document: 
    toc: yes
    toc_depth: 2
    fig_width: 9
    fig_height: 7.5
  html_document:
    toc: yes
    toc_depth: 2
    number_sections: no
---

Goldsmiths College, University of London.

Advanced Econometrics.



# Introduction

This project relies on various statistical methods to provide empirical content on the economic relationship between the Capacity Utilisation Rate and the Inflation Rate of the USA. Indeed, Inflation is highly correlated with the nominal interest rate as when inflation rises, the central bank raises the nominal interest rate to counter it, thus reducing the growth rate of GDP to maintain inflation at acceptable levels for economic functionality. However, the Federal Reserve ends up reducing both demand and supply in the process and, thus, capacity utilisation decreases. Initially, the project analyses the trend and correlation of the variables and collects evidence on the possible presence of unit roots in the variables in levels and in first differences through the ADF, PP, and KPSS tests. Afterwards, the long-run relationship (cointegration) between the two series is analysed through the Engle-Granger and Johansen Tests. The subsequent statistical method of the projects is the ARDL model testing how Capacity Utilisation is adapting in response to Inflation, but the model is not correctly specified. Therefore, as cointegration test results appear to be ambiguous, and as there is evidence of the absence of unit roots in the variables in first differences, the Bivariate VAR Model in first differences was computed, followed by the Granger Causality test, Cholesky decompositions for orthogonal errors, Impulse Response Functions (IRFs), and VAR prediction. Finally, a forecast of inflation in the next 10 months is constructed through the ARIMA model, and a within forecast through the SARIMA model is compared to it.

```{r, warning=FALSE, message=FALSE}

library(forecast)         # For ARIMA model estimation
library(tseries)          # for time series models and diagnostic checks
library(nlme)             # to estimate ARIMA models
library(pdfetch)          # to fetch data directly from online data bases
library(zoo)              # for the zoo function for daily time series
library(urca)             # for unit root tests
library(vars)             # for Granger tests and VAR estimation
library(car)              # for regression diagnostics and hypothesis testing
library(dynlm)            # for Vector Error Correction Model(VECM)
library(tsDyn)            # for linear and non-linear VAR and VECM models
library(gets)             # for Isat function: step and impsulse indicator saturation
library(readxl)           # to read Excel files and load the data from Excel files
library(aod)              # for Wald tests
library(aTSA)             # Engle-Granger cointegration test
library(rmarkdown)        # Rmarkdown package
library(tinytex)          # To render the Latex version of your project


rm(list=ls())

```

# Dataset Properties

The dataset for this project is comprised of TCU and Inflation with 663 values in levels from 01/1967 to 04/2022, obtained from the Federal Reserve Economic Data (FRED).

The Consumer Price Index for All Urban Consumers (CPIAUCSL) is a price index of a basket of goods and services paid by urban consumers. Percent changes in the price index measure the inflation rate between any two time periods. The CPI is used to derive the monthly inflation rate correctly calculated year-on-year and aligned to the properties of the TCU data.

```{r, warning=FALSE, message=FALSE}

CPI = pdfetch_FRED("CPIAUCSL")
names(CPI) = "CPI"

Inflation = diff(log(CPI), lag = 12) * 100                       
names(Inflation) = "Inflation"

Inflation = ts(Inflation, start=c(1947, 1), frequency=12)         
Inflation = na.omit(Inflation)
                                    
```

Capacity Utilisation: Total Industry (TCU) is the amount of capacity being used from the total available capacity to produce demanded finished goods and services. It is the percentage of resources used by corporations and factories to produce goods in manufacturing, mining, and electric and gas utilities for all facilities located in the USA. 

```{r, warning=FALSE, message=FALSE}


TCU = pdfetch_FRED("TCU")
names(TCU) = "TCU"
TCU = ts(TCU, start=c(1967, 1), frequency=12)


data.set = na.omit(
           ts.intersect(

	   Inflation,
	   TCU, 

           dframe=TRUE))


Inflation   = ts( data.set$Inflation,    start=c(1967, 1),  frequency=12)
TCU         = ts( data.set$TCU,          start=c(1967, 1),  frequency=12)


data.set = ts(data.set, start=c(1967, 1), frequency=12)   
	
```

# variables in levels

## Trend plots in levels

As it can be inferred from the plots, there is a graphical indication of the presence of a unit root in both series in levels as the respective means of the stochastic processes appear to be decreasing and not reverting over time. Furthermore, the plots suggest cointegration as the series seem to follow a similar trend.

```{r, warning=FALSE, message=FALSE}

par(mfrow=c(3,1))

plot(Inflation,
main = "US Monthly Inflation",
xlab = "Year",
ylab = "%")
plot(TCU,
main = "US Monthly TCU",
xlab = "Year",
ylab = "%")
plot(data.set, 
main = "US Monthly Inflation and TCU",
xlab = "year",
ylab = "%",
plot.type="single", col = 1:ncol(data.set))
legend("topright", colnames(data.set), col=1:ncol(data.set), lty=1, cex=.65)


```

## Correlation and correlation plot in levels

Inflation and TCU are positively correlated.


```{r, warning=FALSE, message=FALSE}

cor(Inflation, TCU)

```
```{r, warning=FALSE, message=FALSE}

plot(Inflation ~ TCU,
pch = 16, col = 2,
main = "Correlation between US Monthly Inflation and TCU",
xlab = "Inflation",
ylab = "TCU")
lm_Inflation <- lm(Inflation ~ TCU) 
abline(coef(lm_Inflation), lwd = 2)

```

# Variables in first differences 

```{r, warning=FALSE, message=FALSE}


Inflation    =  diff(Inflation)
TCU          =  diff(TCU)



data.set = na.omit(
           ts.intersect(

	   Inflation,
	   TCU, 

           dframe=TRUE))


Inflation   = ts( data.set$Inflation,    start=c(1967, 2),  frequency=12)
TCU         = ts( data.set$TCU,          start=c(1967, 2),  frequency=12)

  data.set = ts(data.set, start=c(1967, 2), frequency=12)  

```

## Trend plots in first differences

As it can be inferred from the plots, there is a graphical indication of the absence of a unit root in both series in first differences as the respective means of the possibly stationary processes appear to be reverting over time.

```{r, warning=FALSE, message=FALSE}

par(mfrow=c(3,1))

plot(Inflation,
main = "US Monthly Inflation in First Differences",
xlab = "Year",
ylab = "%")
plot(TCU,
main = "US Monthly TCU in First Differences",
xlab = "Year",
ylab = "%")
plot(data.set, 
main = "US Monthly Inflation and TCU in First Differences",
xlab = "year",
ylab = "%",
plot.type="single", col = 1:ncol(data.set))
legend("bottomleft", colnames(data.set), col=1:ncol(data.set), lty=1, cex=.65)

```
## Correlation and correlation plot in first differences

```{r, warning=FALSE, message=FALSE}

cor(Inflation, TCU)

```
Correlation is weaker in first differences.

```{r, warning=FALSE, message=FALSE}

plot(Inflation ~ TCU,
pch = 16, col = 2,
main = "Correlation between US Monthly Inflation and TCU in First Differences",
xlab = "Inflation",
ylab = "TCU")
lm_Inflation <- lm(Inflation ~ TCU) 
abline(coef(lm_Inflation), lwd = 2)

```

# Unit Root Tests

## Dataset in levels for unit root tests

```{r, warning=FALSE, message=FALSE}

CPI = pdfetch_FRED("CPIAUCSL")
names(CPI) = "CPI"

Inflation = diff(log(CPI), lag = 12) * 100                        
names(Inflation) = "Inflation"

Inflation = ts(Inflation, start=c(1947, 1), frequency=12)         
Inflation = na.omit(Inflation)

TCU = pdfetch_FRED("TCU")
names(TCU) = "TCU"
TCU = ts(TCU, start=c(1967, 1), frequency=12)


data.set = na.omit(
           ts.intersect(

	   Inflation,
	   TCU, 

           dframe=TRUE))


Inflation   = ts( data.set$Inflation,    start=c(1967, 1),  frequency=12)
TCU         = ts( data.set$TCU,          start=c(1967, 1),  frequency=12)



data.set = ts(data.set, start=c(1967, 1), frequency=12)   
	
```
## Plots of the lag correlation

The plot shows the correlation of the variable with itself throughout 6 months. The closer the dots are to the line, the higher the correlation. Correlation over time is autocorrelation which indicates the presence of a unit root.

The correlation of Inflation and TCU in levels is persistent over 6 months. There is a strong suggestion for unit root presence.

```{r, warning=FALSE, message=FALSE}

x = Inflation                           

lag.plot(x, 6, do.lines=FALSE)

```

```{r, warning=FALSE, message=FALSE}

y = TCU                             

lag.plot(y, 6, do.lines=FALSE)


```

For Inflation and TCU in first differences, correlation is weakened as it can be suggested that the differential of the variable eliminates the unit root.

```{r, warning=FALSE, message=FALSE}

w = diff(Inflation)                  

lag.plot(w, 6, do.lines=FALSE)

```

```{r, warning=FALSE, message=FALSE}

z = diff(TCU)                    

lag.plot(z, 6, do.lines=FALSE)

```
## ACF and PACF plots


Inflation and TCU in levels show a strong persistence, whereas in first differences the persistence weakens.

```{r, warning=FALSE, message=FALSE}

par(mfrow=c(2,2))
acf     (x,          main="ACF for x")
acf     (y,          main="ACF for y")
acf     (w,          main="ACF for w")
acf     (z,          main="ACF for z")

```

Inflation and TCU are auto-regressive processes of order 1.

```{r, warning=FALSE, message=FALSE}

par(mfrow=c(2,2))
pacf    (x,          main="PACF for x")
pacf    (y,          main="PACF for y")
pacf    (w,          main="PACF for w")
pacf    (z,          main="PACF for z")

```

TCU and Inflation seem non-stationary I(1) in levels and stationary I(0) in first differences. Nevertheless, unit root tests are required.

## ADF test

Ho: residuals have a unit root and therefore the series is not stationary.

```{r, warning=FALSE, message=FALSE}

max.lags = trunc(  (12 * (  (length(x)/100)^(1/4)  ) ) )
max.lags
x.adf.drift <- ur.df(x, selectlags="BIC", type="drift", lags=max.lags )                     ### autoregression test with a constant but no trend.
summary(x.adf.drift)

```
The test statistic of Inflation in levels is -2.79 which is less negative than the critical value at the 5% significance level (-2.86). Therefore, Ho cannot be rejected.

```{r, warning=FALSE, message=FALSE}

max.lags = trunc(  (12 * (  (length(y)/100)^(1/4)  ) ) )
max.lags
y.adf.drift <- ur.df(y, selectlags="BIC", type="drift", lags=max.lags )                     ### autoregression test with a constant but no trend.
summary(y.adf.drift)

```

For TCU in levels, Ho can be rejected at the 5% significance level but not at the 1% significance level.

```{r, warning=FALSE, message=FALSE}

max.lags = trunc(  (12 * (  (length(w)/100)^(1/4)  ) ) )
max.lags
w.adf.drift <- ur.df(w, selectlags="BIC", type="drift", lags=max.lags )                     ### autoregression test with a constant but no trend.
summary(w.adf.drift)

```

For Inflation in first difference, Ho can be rejected at the 5% significance level.

```{r, warning=FALSE, message=FALSE}

max.lags = trunc(  (12 * (  (length(z)/100)^(1/4)  ) ) )
max.lags
z.adf.drift <- ur.df(z, selectlags="BIC", type="drift", lags=max.lags )                     ### autoregression test with a constant but no trend.
summary(z.adf.drift)

```
For TCU in first difference, Ho can be rejected at the 5% significance level. 

According to the ADF tests at the 5% significance level, Inflation in levels has a unit root I(1) does not in first differences I(0). TCU does not have a unit root in levels I(0) and first differences I(0).


```{r, warning=FALSE, message=FALSE}

plot(x.adf.drift)

```

```{r, warning=FALSE, message=FALSE}

plot(y.adf.drift)

```

```{r, warning=FALSE, message=FALSE}

plot(w.adf.drift)

```

```{r, warning=FALSE, message=FALSE}

plot(z.adf.drift)

```

## PP test

Ho: residuals have a unit root.

```{r, warning=FALSE, message=FALSE}

x.pp <- ur.pp(x, type="Z-tau", model="constant", lags="long") 
summary(x.pp)

```

The test statistic which is -2.57 is less negative than the critical values at the 5% significance level. The series is non-stationary because the Ho cannot be rejected. the PP test just as the ADF test indicates the presence of a unit root in the inflation rate in levels.


```{r, warning=FALSE, message=FALSE}

y.pp <- ur.pp(y, type="Z-tau", model="constant", lags="long") 
summary(y.pp)

```

For TCU in levels. Ho can be rejected at the 5% significance level. 

```{r, warning=FALSE, message=FALSE}

w.pp <- ur.pp(w, type="Z-tau", model="constant", lags="long") 
summary(w.pp)

```

For Inflation in first differences, Ho is rejected at the 5% significance level.

```{r, warning=FALSE, message=FALSE}

z.pp <- ur.pp(z, type="Z-tau", model="constant", lags="long") 
summary(z.pp)

```

For TCU in first differences, the Ho is rejected at the 5% significance level.

According to the PP tests, TCU is I(0) in levels and first differences, whereas Inflation is I(1) and I(0) respectively.

The plots of the PP results are shown below.

```{r, warning=FALSE, message=FALSE}

plot(x.pp)

```

```{r, warning=FALSE, message=FALSE}

plot(y.pp)

```

```{r, warning=FALSE, message=FALSE}

plot(w.pp)

```

```{r, warning=FALSE, message=FALSE}

plot(z.pp)

```

## KPSS tests

Ho: residuals do not have a unit root and the series is stationary.


```{r, warning=FALSE, message=FALSE}

x.kpss <- ur.kpss(x, type="mu",  lags="long" )
summary(x.kpss)

```

In Inflation in levels, the test statistic is 1.576 which is greater than the critical value at the 5% significance level. the Ho is rejected, and the series cannot be stationary because there is a unit root. 

```{r, warning=FALSE, message=FALSE}

y.kpss <- ur.kpss(y, type="mu",  lags="long" )
summary(y.kpss)

```

For TCU in levels, Ho is rejected at the 5% significance level.

```{r, warning=FALSE, message=FALSE}

w.kpss <- ur.kpss(w, type="mu",  lags="long" )
summary(w.kpss)

```

For Inflation in first differences, Ho is not rejected at the 5% significance level.

```{r, warning=FALSE, message=FALSE}

z.kpss <- ur.kpss(z, type="mu",  lags="long" )
summary(z.kpss)

```

For TCU in first differences, Ho is not rejected at the 5% level of significance.


According to the KPSS Inflation and TCU are I(1) in levels and I(0) in first differences at the 5% significance level.


```{r, warning=FALSE, message=FALSE}

plot(x.kpss)

```

```{r, warning=FALSE, message=FALSE}

plot(y.kpss)

```

```{r, warning=FALSE, message=FALSE}

plot(w.kpss)

```

```{r, warning=FALSE, message=FALSE}

plot(z.kpss)

```
The plots show that the trend of Inflation and TCU is a random walk with drift, accounted for by running the tests with a constant.


# Cointegration Analysis

As the unit root tests results are inconclusive in levels at the 5% significance level, but both series are I(0) in first differences they might be cointegrated.

## Engle-Granger Methodology

Ho: no cointegration

```{r, warning=FALSE, message=FALSE}

coint.test(Inflation, TCU,           d = 0, nlag = NULL, output = TRUE)                             # in levels

```

Ho cannot be rejected at the 5% significance level (p value=0.0876).

```{r, warning=FALSE, message=FALSE}


Inflation and TCU seem to not be cointegrated in levels at the 5% significance level.

## Johansen test

Ho: no cointegration vector.


```{r, warning=FALSE, message=FALSE}

VARselect(data.set, lag.max=10, type="const", season = NULL, exogen = NULL)$selection	  


```

```{r, warning=FALSE, message=FALSE}

optimal.lags = 2


johansen.const = ca.jo(data.set, type="eigen", ecdet="const",  K = optimal.lags, spec="longrun")
	summary(johansen.const)

```

The test statistic 19.75 is greater than the critical value 15.67 at the 5% significance level. Ho is rejected at the 5% significance level as there is evidence of a cointegrating vector. However, Ho is also rejected when the rank of the pi matrix is equal to 1, which is logically impossible as the variables are 2. 

```{r, warning=FALSE, message=FALSE}

johansen.const = ca.jo(data.set, type="trace", ecdet="const",  K = optimal.lags, spec="longrun")
	summary(johansen.const)

```

Ho is rejected at the 5% significance level for both ranks again.
 
The tests cannot establish a meaningful correlation.

The Cointegration relation seems to be stationary for TCU but not for Inflation.

```{r, warning=FALSE, message=FALSE}

plot(johansen.const)

```

```{r, warning=FALSE, message=FALSE}

plotres(johansen.const)

```

Inflation and TCU seem to not be cointegrated in levels.


# ARDL

## Create the Data Frame in levels for the ARDL


```{r, warning=FALSE, message=FALSE}

library(dynamac)          

CPI = pdfetch_FRED("CPIAUCSL")
names(CPI) = "CPI"

Inflation = diff(log(CPI), lag = 12) * 100                       
names(Inflation) = "Inflation"

Inflation = ts(Inflation, start=c(1947, 1), frequency=12)         
Inflation = na.omit(Inflation)

TCU = pdfetch_FRED("TCU")
names(TCU) = "TCU"
TCU = ts(TCU, start=c(1967, 1), frequency=12)

data.set = na.omit(
           ts.intersect(

	   Inflation,
	   TCU, 

           dframe=TRUE))


Inflation   = ts( data.set$Inflation,    start=c(1967, 1),  frequency=12)
TCU         = ts( data.set$TCU,          start=c(1967, 1),  frequency=12)


```

The model in the error correction is computing the impact of Inflation on the TCU.

```{r, warning=FALSE, message=FALSE}


set.seed(123)

lags = 2      

ARDL = dynardl(	
                      TCU ~ Inflation,                                               
                                                                                         
                lags = list("Inflation" = 1,          "TCU" = 1             ),           
               diffs =    c("Inflation"                                          ),       
            lagdiffs = list("Inflation" = c(1:lags),  "TCU" = c(1:lags)     ),           
	
                  ec = TRUE,                
            constant = TRUE,
               trend = FALSE,

            simulate = FALSE,              
            shockvar = "Inflation",      
               range = 50,
                sims = 1000,       
            fullsims = TRUE,

                data = data.set)


summary(ARDL)

```

The model with the current variables is not a good fit because the r-squared is 0.1266.

## PSS tests

```{r, warning=FALSE, message=FALSE}

pssbounds(ARDL)

```

Ho is rejected because the F-statistic 7.9 is greater than the critical value at the 1% significance level. The lagged levels are statistically significant.

```{r, warning=FALSE, message=FALSE}

pssbounds(ARDL, restriction=TRUE) 

```

Ho is not rejected at the 1% significance level but it is rejected at the 5% significance level.

## Diagnostic checks 


```{r, warning=FALSE, message=FALSE}

dynardl.auto.correlated(ARDL) 

```

Breusch-Godfrey test’s Ho of no autocorrelation cannot be rejected at the 5% significance level.
Shapiro-Wilk test’s Ho of normal distribution is rejected at the 5% significance level.


```{r, warning=FALSE, message=FALSE}

ARDL.residuals =    ARDL$model$residuals
ARDL.residuals = ts(ARDL$model$residuals,  start=c(1967, 1) ,  frequency=1)



  par(mfrow = c(2, 2))
      plot( ARDL.residuals )                 
    abline( h=0, col="red" )
      hist( ARDL.residuals, col="orange")  
       acf( ARDL.residuals )                 
      pacf( ARDL.residuals )                 

```

The distribution is left-skewed with a very long negative spike on the right side of the residuals plot. The ACF and PACF indicate no serial correlation in the residuals.


```{r, warning=FALSE, message=FALSE}

jarque.bera.test(ARDL.residuals)      

```

Ho of normality is rejected at the 1% significance level.

```{r, warning=FALSE, message=FALSE}


bptest(ARDL$model)                   


```

Ho of no heteroskedasticity is rejected at the 1% significance level.


Heteroskedasticity needs to be corrected.


```{r, warning=FALSE, message=FALSE}

coeftest(ARDL$model, vcov.=vcovHC )  

```

Standard errors are greater and t values are lower when heteroskedasticity is corrected. The regressors are less significant.


## IRFs

The model is run with robust errors to plot the IRFs for the bootstrapped confidence interval over 50 months, with the exogenous shock coming from Inflation

```{r, warning=FALSE, message=FALSE}

ARDL = dynardl(	
                      TCU ~ Inflation,                                                
                                                                                          
                lags = list("Inflation" = 1,          "TCU" = 1             ),           
               diffs =    c("Inflation"                                          ),           
            lagdiffs = list("Inflation" = c(1:lags),  "TCU" = c(1:lags)     ),            
	
                  ec = TRUE,                
            constant = TRUE,
               trend = FALSE,

            simulate = TRUE,             
            shockvar = "Inflation",      
               range = 50,
                sims = 1000,      
            fullsims = TRUE,

                data = data.set)


summary(ARDL)

```
According to the coefficients of the model, in explaining the current value TCU, the differenced first lag of Inflation is significant at the 0.1 % level and has a positive impact on the TCU. 

```{r, warning=FALSE, message=FALSE}

dynardl.all.plots(ARDL)

```
The cumulative change in the dependent variable indicates that when Inflation increases, the TCU increases as well. After 1 year, TCU increases by 1 p.p after a shock of one unit to Inflation. Afterwards, TCU exhibits a downward trend.

In conclusion, The ARDL model confirms the argument constructed at the beginning of the project. Nevertheless, the model is not correctly specified because the R-squared is low and the residuals are not well-behaving. Inflation needs to be complemented with more variables to predict TCU.




#  Bivariate VAR Model


In the ARDL model, the independent variables are exogenous, but it is very difficult to apply such analysis in reality. The VAR model attempts to overcome the ubiquitous endogeneity problem by treating all the variables in the model as endogenous to one another. As there is no evidence of cointegration and the variables are non-stationary in levels, it is necessary to run a VAR model in first differences.

## Data frame in first differences

```{r, warning=FALSE, message=FALSE}

CPI = pdfetch_FRED("CPIAUCSL")
names(CPI) = "CPI"

Inflation = diff(log(CPI), lag = 12) * 100                        # Percent change from year ago
names(Inflation) = "Inflation"

Inflation = ts(Inflation, start=c(1947, 1), frequency=12)         
Inflation = na.omit(Inflation)

TCU = pdfetch_FRED("TCU")
names(TCU) = "TCU"
TCU = ts(TCU, start=c(1967, 1), frequency=12)


Inflation    =  diff(Inflation)
TCU          =  diff(TCU)



data.set = na.omit(
           ts.intersect(

	   Inflation,
	   TCU, 

           dframe=TRUE))


Inflation   = ts( data.set$Inflation,    start=c(1967, 2),  frequency=12)
TCU         = ts( data.set$TCU,          start=c(1967, 2),  frequency=12)

  data.set = ts(data.set, start=c(1967, 2), frequency=12)   

```

## Optimal Lag Selection in first differences

```{r, warning=FALSE, message=FALSE}

VARselect(data.set, lag.max=10, type="const", season = NULL, exogen = NULL)$selection	  

```
## Model results

```{r, warning=FALSE, message=FALSE}

optimal.lags = 1 


var.model.const  <- VAR(data.set, p=optimal.lags, type="const", exogen=NULL)
summary(var.model.const)

```

According to the coefficients of the model, in explaining the current value TCU, the first lag of Inflation is significant at the 5% level. Therefore, the cumulative IRFs are expected to show an increase in TCU after a shock of one unit to Inflation. Nevertheless, the R-squared is very close to 0, thus the model is not correctly specified.

```{r, warning=FALSE, message=FALSE}

plot(var.model.const)


```

There is no persistence in the residuals.

## Granger-causality tests with robust errors

```{r, warning=FALSE, message=FALSE}

causality(var.model.const, cause="Inflation", boot=FALSE, boot.runs=1000, vcov.=vcovHC(var.model.const))

```

The p-value is 0.099. There is no evidence of Granger-causality from Inflation to TCU only at 10% significance level.

```{r, warning=FALSE, message=FALSE}

causality(var.model.const, cause="TCU", boot=FALSE, boot.runs=1000, vcov.=vcovHC(var.model.const))

```

No evidence of Granger-causality from the TCU to Inflation.

## Cholesky decompositions for orthogonal errors


Due to the Granger-causality results, the optimal ordering is from Inflation to TCU. Non-cumulative and cumulative IRFs are computed accordingly.

```{r, warning=FALSE, message=FALSE}

ordered.data.set = data.set[, c("Inflation","TCU")]

var.ordered.const  <- VAR(ordered.data.set,  p=optimal.lags,   type="const",   exogen=NULL)

```

```{r, warning=FALSE, message=FALSE}

plot(irf(var.ordered.const, n.ahead=20, ortho=TRUE, cumulative=FALSE, boot=TRUE, ci=0.90, runs=100))

plot(irf(var.ordered.const,  impulse="Inflation", response="TCU", n.ahead=20, ortho=TRUE, cumulative=FALSE, boot=TRUE, ci=0.90, runs=100, seed=NULL),
			main="Inflation to TCU", xlab="Lag", ylab="", sub="", oma=c(3,0,3,0))

```

TCU remains inside the red lines and therefore when affected by Inflation behaves well. The IRFs converge to 0 over time, as expected because unit roots are absent.

```{r, warning=FALSE, message=FALSE}

plot(irf(var.ordered.const, n.ahead=20, ortho=TRUE, cumulative=TRUE, boot=TRUE, ci=0.90, runs=100))

plot(irf(var.ordered.const,  impulse="Inflation", response="TCU", n.ahead=20, ortho=TRUE, cumulative=TRUE, boot=TRUE, ci=0.90, runs=100, seed=NULL),
			main="Inflation to TCU", xlab="Lag", ylab="", sub="", oma=c(3,0,3,0))

```

The IRFs do not converge to 0 overtime and the impulse is positive as expected. Residuals seem well-behaving.

## Diagnostic checks

```{r, warning=FALSE, message=FALSE}

serialtest <- serial.test(var.model.const, type = "PT.asymptotic")
serialtest

```
There is evidence of autocorrelation (p-value < 0.05).


```{r, warning=FALSE, message=FALSE}

serialtest <- serial.test(var.model.const, type = "PT.adjusted")
serialtest

```

There is evidence of autocorrelation.


```{r, warning=FALSE, message=FALSE}

serialtest <- serial.test(var.model.const, type = "BG")
serialtest

```
There is evidence of no autocorrelation.

```{r, warning=FALSE, message=FALSE}

serialtest <- serial.test(var.model.const, type = "ES")
serialtest

```
There is evidence of no autocorrelation.


```{r, warning=FALSE, message=FALSE}

normalitytest <- normality.test(var.ordered.const)
normalitytest

```
The residuals are not normally distributed.

The residuals might be autocorrelated, and they are not normally distributed. The model is not correctly specified.

## VAR model forecast

```{r, warning=FALSE, message=FALSE}

var.prd.const <- predict(var.model.const, n.ahead = 10, ci = 0.95)
plot(var.prd.const)

```
Inflation and TCU exhibit a downward forecasted trend in the next 10 months.


# ARIMA Models for Forecasting

The ARIMA model uses only one variable, modelled in relation to its past behaviour, to identify how one variable can predict itself in the future.

## Data frame in levels

```{r, warning=FALSE, message=FALSE}

CPI = pdfetch_FRED("CPIAUCSL")
names(CPI) = "CPI"

Inflation = diff(log(CPI), lag = 12) * 100                      
names(Inflation) = "Inflation"

Inflation = ts(Inflation, start=c(1947, 1), frequency=12)         
Inflation = na.omit(Inflation)

TCU = pdfetch_FRED("TCU")
names(TCU) = "TCU"
TCU = ts(TCU, start=c(1967, 1), frequency=12)


data.set = na.omit(
           ts.intersect(

	   Inflation,
	   TCU, 

           dframe=TRUE))


Inflation   = ts( data.set$Inflation,    start=c(1967, 1),  frequency=12)
TCU         = ts( data.set$TCU,          start=c(1967, 1),  frequency=12)



data.set = ts(data.set, start=c(1967, 1), frequency=12)   

```
## ARIMA model selection

The model will predict the behaviour of Inflation.

```{r, warning=FALSE, message=FALSE}

x = Inflation

   arima.model = forecast::auto.arima(x,
	
                                  D = 1,
                         stationary = FALSE,
                                 ic = c("aicc", "aic", "bic"),
                           stepwise = FALSE,
                      approximation = FALSE,
                           seasonal = TRUE,
                         allowdrift = TRUE   ) 


arima.model

```

The best model for predicting the trend of Inflation is ARIMA (2,0,0) (2,1,0) [12]. The model is AR(2) therefore the current value is based on the previous 2 values. Also, the best model is in levels and does not rely on the moving average of past forecasting errors, MA(0).

## ARIMA forecast

```{r, warning=FALSE, message=FALSE}

ARIMA.forecast = forecast::forecast(arima.model, h = 10)

plot(ARIMA.forecast)

```

In the next 10 months, Inflation decreases, but the confidence intervals are wide. 

## SARIMA forecast

To compare the prediction of the ARIMA model, the SARIMA model will be computed for a within-sample forecast.                       

```{r, warning=FALSE, message=FALSE}


library(smooth)

sarima.model = smooth::msarima(x, orders=list(

                                               ar = c(2,2),
                                                i = c(0,1),
                                               ma = c(1,0)),
                                             lags = c(1,12),
                                                h = 10,        
                                          holdout = TRUE)

sarima.model

```

The estimated SARIMA model is (2,0,1)[1] (2,1,0) [12].


```{r, warning=FALSE, message=FALSE}


summary(sarima.model)

values = sarima.model

greybox::graphmaker(x,values$forecast,values$fitted,values$lower,values$upper,level=0.95,legend=TRUE)


```

According to the forecast, inflation should have decreased in the last 10 months but according to present values, it has increased. The SARIMA model could not reliably predict the future, thus the ARIMA model might not be meaningful.


# conclusion

The variables appeared to be I(1) in levels and I(0) in first differences. However, the unit root tests results are conflicting as TCU is I(0) in levels and in first differences at the 5% significance level, according to the ADF and PP tests. Nevertheless, both series are I(0) in levels, and it was assumed that they are I(1) in levels. As cointegration tests results were ambiguous, it was assumed that there is no cointegration between the two variables. The ARDL model was not correctly specified but the PSS tests indicated a long-run relationship at the 5% significance level from Inflation to TCU, and a positive impact could be inferred from the IRFs. Following the results of the project the VAR model was computed and the Granger-causality test indicated a Granger-causality at the 10% significance level from Inflation to TCU. The VAR IRFs were computed and again TCU seemed to adapt to Inflation. A VAR forecast was constructed, showing a decrease in Inflation in the next 10 months. Nevertheless, the residuals were not normally distributed and the R-squared was too low. The ARIMA forecast was constructed and compared to the SARIMA forecast. The SARIMA could not predict the past behaviour of inflation, thus the ARIMA model appears to be inadequate for Inflation forecasting. The results of the project are not adequate to accurately assess the significance of causality from Inflation to TCU and the Auto-Regressive behaviour of Inflation. Further research is required for meaningful results.




##Panel Data


```{r, warning=FALSE, message=FALSE}

library(lmtest)             # For diagnostic checks
library(texreg)             # 
library(tidyr)              # For tables and summaries of outputs
library(dplyr)              # For tables and data manipulation
library(pdfetch)            # to fetch data directly from online data bases
library(foreign)            # Panel data plots and visualizations
library(car)                # For plots
library(gplots)             # For plots
library(tseries)            # For time series and unit root tests
library(sjPlot)             # For consolidated regression tables
library(huxtable)           # For consolidated regression tables
library(ivreg)              # For 2SLS and instrumental variables (IV)
library(plm)                # Panel Data Models

rm(list=ls())

```

```{r, warning=FALSE, message=FALSE}

wdi = read.csv("wdi.csv", na.strings = "NA")

```

## Pooled OLS Model

```{r, warning=FALSE, message=FALSE}

 pooled_OLS = plm(MaternalMortality ~ SafeWaterAccess + HealthExpenditure + PregnantWomenWithAnemia + IncomePerCapita, 
                      data   = wdi, 
                      index  = c("Country", "Year"), 
                      model  = "pooling")


 summary(pooled_OLS)

```

## Individual Fixed Effects Model

```{r, warning=FALSE, message=FALSE}

 fixed_effects = plm(MaternalMortality ~ SafeWaterAccess + HealthExpenditure + PregnantWomenWithAnemia + IncomePerCapita, 
                      data   = wdi, 
                      index  = c("Country", "Year"), 
                      model  = "within", 
                      effect = "individual")


 summary(fixed_effects)

```

## Time Fixed Effects Model

```{r, warning=FALSE, message=FALSE}

 time_effects = plm(MaternalMortality ~ SafeWaterAccess + HealthExpenditure + PregnantWomenWithAnemia + IncomePerCapita, 
                      data = wdi, 
                      index = c("Country", "Year"), 
                      model = "within", 
                      effect = "time")

 summary(time_effects)

```

## Twoway Fixed Effects Model

```{r, warning=FALSE, message=FALSE}

  twoway_effects = plm(MaternalMortality ~ SafeWaterAccess + HealthExpenditure + PregnantWomenWithAnemia + IncomePerCapita, 
                          data = wdi, 
                          index = c("Country", "Year"), 
                          model = "within", 
                          effect = "twoways")

  summary(twoway_effects)

```

## First Table of Comparison

```{r, warning=FALSE, message=FALSE}


     screenreg(list(    pooled_OLS,
                        fixed_effects, 
                        time_effects, 
                        twoway_effects), 
          
          custom.model.names = c("Pooled OLS", 
                                 "Country FE", 
                                 "Time FE", 
                                 "Two-way FE"))

```

## Random Effects Twoway Model

```{r, warning=FALSE, message=FALSE}

  RE_twoway = plm( MaternalMortality ~ SafeWaterAccess + HealthExpenditure + PregnantWomenWithAnemia + IncomePerCapita,
 
                          data   = wdi, 
                          index  = c("Country", "Year"), 
                          model  = "random", 
                          effect = "twoways",
                   random.method = "swar" )


  summary(RE_twoway)

```

## Second Table of Comparison

```{r, warning=FALSE, message=FALSE}

     screenreg(list(   pooled_OLS,
                       twoway_effects,
                       RE_twoway), 
          
          custom.model.names = c("Pooled OLS", 
                                 "Two-way FE",
                                 "Two-way RE" ))


```

## Lagged Dependent Variables (LDV) and Dynamic Models

```{r, warning=FALSE, message=FALSE}

  ldv_model = plm(MaternalMortality ~ lag(MaternalMortality) + SafeWaterAccess + HealthExpenditure + PregnantWomenWithAnemia + IncomePerCapita, 

                          data = wdi, 
                         index = c("Country", "Year"), 
                         model = "within", 
                        effect = "twoways" )

  summary(ldv_model)

```

## Third Table of Comparison

```{r, warning=FALSE, message=FALSE}

     screenreg(list(   pooled_OLS,
                       twoway_effects,
                       RE_twoway,
                       ldv_model), 
          
          custom.model.names = c("Pooled OLS", 
                                 "Twoway FE",
                                 "Twoway RE",
                                 "LDV Model"))

```

## Poolability Tests

```{r, warning=FALSE, message=FALSE}

pFtest(fixed_effects, pooled_OLS)

# FE > Pooled OLS

```

```{r, warning=FALSE, message=FALSE}

pFtest(twoway_effects, pooled_OLS) 

#TWFE > Pooled OLS

```

```{r, warning=FALSE, message=FALSE}

plmtest(fixed_effects, effect="individual")

# no country fixed effects present in the Individual FE model

```

```{r, warning=FALSE, message=FALSE}

plmtest(time_effects, effect="time")

# it is not suggested to control for Time Effects only
```

```{r, warning=FALSE, message=FALSE}

plmtest(twoway_effects, effect="twoways")

# control for both individual and time effetcs (twoway)
```

## Hausman Test

```{r, warning=FALSE, message=FALSE}

phtest(twoway_effects, RE_twoway)

# RE > twoway FE

```

```{r, warning=FALSE, message=FALSE}

phtest(ldv_model, RE_twoway)

# LDV > RE

```

## serial correlation tests

```{r, warning=FALSE, message=FALSE}

pbgtest(twoway_effects)

# Ho is rejected: there is serial correlation

```

```{r, warning=FALSE, message=FALSE}

pbgtest(RE_twoway)

# Ho is rejected: there is serial correlation

```

```{r, warning=FALSE, message=FALSE}

pbgtest(ldv_model)

# Ho is rejected: there is serial correlation

```

## Corrections for heteroskedasticity and autocorrelation (HAC)

```{r, warning=FALSE, message=FALSE}

  twoway_effects_hac = coeftest(twoway_effects, 
                                                vcov = vcovHC(twoway_effects, 
                                              method = "arellano", 
                                              type   = "HC3"))

  twoway_effects_hac

```

## Table of comparison between standard and robust errors

```{r, warning=FALSE, message=FALSE}

   screenreg(list(
                  twoway_effects, 
                  twoway_effects_hac),
          
                  custom.model.names = c("Twoway Fixed Effects", 
                                         "Twoway Fixed Effects (HAC)"))


```

## Cross Sectional Dependence (XSD) Test

```{r, warning=FALSE, message=FALSE}

pcdtest(twoway_effects)

# Ho is rejected: there is evidence of XSD

```

```{r, warning=FALSE, message=FALSE}

pcdtest(RE_twoway)

# Ho is rejected: there is evidence of XSD

```

```{r, warning=FALSE, message=FALSE}

pcdtest(ldv_model)

# Ho is rejected: there is evidence of XSD

```

## Panel Corrected Standard Errors (PCSE)

```{r, warning=FALSE, message=FALSE}

  twoway_effects_pcse = coeftest(twoway_effects, 
                                                 vcov = vcovBK(twoway_effects, 
                                                 type = "HC3", 
                                              cluster = "group")) 

  twoway_effects_pcse

```

## cross-sectional and serial correlation (SCC)

```{r, warning=FALSE, message=FALSE}

  twoway_effects_scc = coeftest(twoway_effects,
                                                  vcov = vcovSCC(twoway_effects, 
                                                  type = "HC3", 
                                               cluster = "group"))

  twoway_effects_scc

```

## Fourth Table of Comparison

```{r, warning=FALSE, message=FALSE}

         screenreg(list(

                    pooled_OLS,
                    RE_twoway, 
                    ldv_model,
                    twoway_effects,
                    twoway_effects_hac, 
                    twoway_effects_pcse, 
                    twoway_effects_scc), 

          custom.model.names = c(

                    "Pooled OLS",
                    "Twoway RE",
                    "LDV FE",
                    "Twoway FE",
                    "Arellano HAC FE", 
                    "Beck-Katz FE",
                    "Driscoll-Kraay FE"))

```

## Baseline non-IV model

```{r, warning=FALSE, message=FALSE}

  twoway_effects = plm(MaternalMortality ~ SafeWaterAccess + HealthExpenditure + PregnantWomenWithAnemia + IncomePerCapita, 

                          data = wdi, 
                          index = c("Country", "Year"), 
                          model = "within", 
                          effect = "twoways")


  summary(twoway_effects)

```

```{r, warning=FALSE, message=FALSE}

coeftest(twoway_effects, vcov = vcovHC, type = "HC1")
coeftest(twoway_effects, vcov = vcovHC, type = "HC2")
coeftest(twoway_effects, vcov = vcovHC, type = "HC3")
coeftest(twoway_effects, vcov = vcovHC, type = "HC4")

```

## Two-stage least squares (2SLS) with external IV

```{r, warning=FALSE, message=FALSE}

      Two_Stage_IV = plm(MaternalMortality ~ SafeWaterAccess + HealthExpenditure + PregnantWomenWithAnemia + IncomePerCapita

                                       | . - IncomePerCapita + OilRents,                 # instruments(IV)


                            data = wdi, 
                           index = c("Country", "Year"), 
                           model = "within", 
                          effect = "twoways",
                     inst.method = "bvk" )                                                                      # type of IV model


      summary(Two_Stage_IV)

```

```{r, warning=FALSE, message=FALSE}

coeftest(Two_Stage_IV, vcov = vcovHC, type = "HC1")
coeftest(Two_Stage_IV, vcov = vcovHC, type = "HC2")
coeftest(Two_Stage_IV, vcov = vcovHC, type = "HC3")
coeftest(Two_Stage_IV, vcov = vcovHC, type = "HC4")

```

## Generalized Method of Moments (GMM) Model

```{r, warning=FALSE, message=FALSE, error=FALSE}

detach("package:dplyr", unload=TRUE)

                  GMM = pgmm(         MaternalMortality ~ 

                                      lag(MaternalMortality,       1:1) +        # lags of the dependent variable
                                      lag(SafeWaterAccess,         0:2) +
                                      lag(HealthExpenditure,       0:2) +
                                      lag(PregnantWomenWithAnemia, 0:2) +        ### contemporaneous and lagged variables of the regressors on the right hand-side
                                      lag(IncomePerCapita,         0:2)
                                                                                 # the process leads to the creation of dynamic model
                                    | lag(MaternalMortality,       2:6),         # GMM instruments


                            data = wdi, 
                           index = c("Country", "Year"), 
                           model = "twostep", 
                          effect = "individual"   )                                                                      



      summary(GMM)

# The instruments are valid according to the Sargan test

```

## GMM using logs and lags of logs

```{r, warning=FALSE, message=FALSE}

             GMM.logs = pgmm(         log(MaternalMortality) ~ 

                                      lag(log(MaternalMortality),       1:1) +        # lags of the dependent variable
                                      lag(log(SafeWaterAccess),         0:2) +
                                      lag(log(HealthExpenditure),       0:2) +
                                      lag(log(PregnantWomenWithAnemia), 0:2) +
                                      lag(log(IncomePerCapita),         0:2)

                                    | lag(log(MaternalMortality),       2:6),         # GMM instruments


                            data = wdi, 
                           index = c("Country", "Year"), 
                           model = "onestep", 
                          effect = "individual"   )                                                                      



      summary(GMM.logs)
```

## IV models in a consolidated table

```{r, warning=FALSE, message=FALSE}

         screenreg(list(

                    twoway_effects,
                    Two_Stage_IV,
                    GMM,
                    GMM.logs
                                  ),

          custom.model.names = c(
 
                    "FE two-way",
                    "Two_Stage_IV",
                    "GMM",
                    "GMM.logs"
                                 ))

```
## Conclusion

The 2SLS is the best model as all variables are significant and have the correct sign. Maternal Mortality decreases with Safe Water Access, Health Expenditure, and Income Per Capita, and increases with Pregnant Women With Anaemia.

```{r, include=FALSE, eval=FALSE}

# This part of the code will not appear in your project as the options above "include=FALSE, eval=FALSE" are set to FALSE.

# Use this code to render your project in the file type that you want: PDF, HTML, or DOCX:

rmarkdown::render( "Advanced Econometrics - Rmarkdown Template.Rmd",   output_format = "pdf_document")
rmarkdown::render( "Advanced Econometrics - Rmarkdown Template.Rmd",   output_format = "html_document")
rmarkdown::render( "Advanced Econometrics - Rmarkdown Template.Rmd",   output_format = "word_document")
```



